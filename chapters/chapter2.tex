% Chapter Template

\chapter{Background and Related Work}

\label{Chapter2}

\lhead{Chapter 2. \emph{Backround and Related Work}} 

\tirth{some intro here? idk}

\section{Theseus}
Theseus\cite{theseus} is a microkernel based operating system written in Rust. Rust's safety guarantees enable Theseus to run all software written in Rust, including userspace applications, to run in a single address space and at a single privilege level. Thus, eliminating the need for virtual memory management and protection rings. Theseus introduces the idea of cells that are described as a software-defined unit of modularity that serves as the core building block of the OS. A cell can be modeled as a crate in Rust. On booting, only the microkernel, ie, the \lstinline{nano_core} is loaded which bootstraps the system. All other cells are dynamically loaded on demand. 
Theseus piggybacks on Rust's safety guarantees to enable reliable IPC between cells. For example, memory mappings are a 1-1 mapping to a physical frame. They can only be shared behind a read-only \lstinline{&MappedPages} reference eliminating the double-free and the use-after-free problem. 

The most important contribution by Theseus is the idea of eliminating (or minimizing) shared state between components. All OS services can be modelled as servers and applications requesting these services are modelled as clients. Theseus eliminates state-spill\cite{state-spill} across cells by eliminating all state from the servers. Everything that is needed to service a client's request is stored in the client itself and thus the servers can be completely stateless. This allows a server cell to be replaced by a new cell without any state loss. This, however, is not always possible. In case a state cannot be eliminated, as in the case of descriptor tables, the state is stored in a \lstinline{state_db}. The \lstinline{state_db} is a key-value database that stores states with a static lifetime that the server can request a (weak) reference to. In case a server needs to be restarted, its state can be recovered from the \lstinline{statedb}. The statelessness of cells also allows for live updates. A server can be replaced, ie, a patch can be applied to a component without having to restart the entire operating system. Applying a patch is as simple as swapping a cell with a new cell.

\tirth{Maybe add limitations and performance evaluations of Theseus here?}

\section{Singularity OS}
Singularity\cite{singularity} introduced "Software Isolated Processes" (SIPs) which use software verification instead of hardware protection mechanisms to isolate processes. SIPs cannot have shared memory. Instead, data can be passed between SIPs using an "exchange heap". Data on the exchange heap can be owned only by a single process but the ownership can be "transferred". Static verification ensure that programs do not try to access an object after it has been passed (ie a dangling pointer). Ownership can be transferred between SIPs using "Contract-Based Channels". Channels are described using statically defined interfaces in the Sing\# language. The communicating SIPs act as state machines with clearly defined states and the messages that can be passed on each state. Once a message has been passed, its data can no longer be used by the sending SIP. Ownership of data on the exchange heap is recorded so that blocks can be freed on process termination preventing memory leaks. This process isolation allows singularity to run the kernel and all SIPs in a single physical address space.

All programs running on Singularity must ship with a manifest. Manifest-based programs clearly define their resource requirements, desired capabilities and dependencies on other programs. The manifest can be used by the system to ensure that the program's requirements can be met and that the program satisfies all correct usage guarantees. The absence of shared memory and static verification of all communication makes the creation and termination of SIPs inexpensive.

\section{RedLeaf}
RedLeaf is a microkernel written in Rust that aims to use Rust's language safety features to ensure fault isolation. RedLeaf forbids the use of shared data between components. Similar to Singularity, data can only be passed between domains using the "Exchange Heap". A domain cannot hold a pointer to an object in a different domain. Redleaf introduces \lstinline{RRefs} for passing data between domains. RRefs are smart-pointers that track the ownership of the allocated object. Along with the pointer, RRefs store the owner of an object and it's current reference count. Types that can be safely shared on the exhange heap are called exchangeable types and only exchangeable types can be passed across domains. Exchangeable types enforce the invariant that objects on the shared heap cannot contain any references to private or shared heap but can contain RRefs pointing to other objects on the shared heap. Rust's ownership discipline enforces that once an object is passed, there are no aliases left in the domain referring to the object. 

Cross-domain calls in RedLeaf are proxied with the help of invocation proxies. The invocation proxy first checks the liveliness of the domain being called. Then, the ownership of all RRefs is moved to the callee domain. RedLeaf also introduces an IDL to validate all interfaces and generate proxy code required for enforcing ownership discipline. The IDL also validates that cross-domain calls only consist of exchangeable types. When a domain crashes, i.e., a thread incurs a panic while in that domain, the domain enters the unwind routine and all subsequent calls to that domain will result in an Error but will not violate memory safety or panic. The unwind routine will restore the state of the domain to the call site eliminating the need for a continuation stack.
